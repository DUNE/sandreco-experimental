//
// Created by paolo on 08/05/2025.
//

#include <ufw/factory.hpp>

#include <duneanaobj/StandardRecord/SRTrueParticle.h>
#include <duneanaobj/StandardRecord/SRRecoParticle.h>

#include <edep_reader/edep_reader.hpp>

#include "fake_reco.hpp"

namespace sand::fake_reco {
    fake_reco::fake_reco() : process{{}, {}} {
    }

    void fake_reco::configure(const ufw::config &cfg) {
        process::configure(cfg);
    }

    void fake_reco::run() {
        // Read input
        const auto &inputTree = get<edep_reader>();

        // Just logging some values
        std::size_t childrenTrajectoriesCount = inputTree.GetChildrenTrajectories().size();

        UFW_DEBUG("Reading root trajectory with id: {}", inputTree.GetId());
        UFW_DEBUG("Children trajectories foud: {}", childrenTrajectoriesCount);

        for (int i = 0; i < childrenTrajectoriesCount; ++i) {
            const auto &childTrajectory = inputTree.GetChildrenTrajectories()[i];
            UFW_DEBUG("Parsing children trajectory number {}", i);

            caf::SRRecoParticle recoParticle{
                .primary = true,
                .pdg = childTrajectory.GetPDGCode(),
                .tgtA = 0, // ?
                .score = std::numeric_limits<float>::signaling_NaN(), // ?
                .E = 0, // ?
                .E_method = caf::PartEMethod::kUnknownMethod, // ?
                .p = caf::SRVector3D{childTrajectory.GetInitialMomentum().Vect()},
                .start = caf::SRVector3D{
                    childTrajectory.GetTrajectoryPointsVect().front().GetPosition().Vect() // are these [cm]?
                },
                .end = caf::SRVector3D{childTrajectory.GetTrajectoryPointsVect().back().GetPosition().Vect()},
                .contained = false, // ?
                .truth = {}, // ?
                .truthOverlap = {} // ?
            };

            caf::SRTrueParticle trueParticle{
                .pdg = childTrajectory.GetPDGCode(),
                .G4ID = -1, // ?
                .interaction_id = childTrajectory.GetId(), // ?
                .time = static_cast<float>(childTrajectory.GetTrajectoryPointsVect().front().GetPosition().T()), // ?
                .ancestor_id = {}, // ?
                .p = childTrajectory.GetInitialMomentum(),
                .start_pos = caf::SRVector3D{
                    childTrajectory.GetTrajectoryPointsVect().front().GetPosition().Vect() // are these [cm]?
                },
                .end_pos = caf::SRVector3D{childTrajectory.GetTrajectoryPointsVect().back().GetPosition().Vect()},
                .parent = childTrajectory.GetParentId(),
                .daughters = {}, // should I get this visiting the whole children tree or just the first layer?
                .first_process = static_cast<unsigned int>(childTrajectory.GetTrajectoryPointsVect().front().
                    GetProcess()),
                .first_subprocess = static_cast<unsigned int>(childTrajectory.GetTrajectoryPointsVect().front().
                    GetSubprocess()),
                .end_process = static_cast<unsigned int>(childTrajectory.GetTrajectoryPointsVect().back().GetProcess()),
                .end_subprocess = static_cast<unsigned int>(childTrajectory.GetTrajectoryPointsVect().back().
                    GetSubprocess())
            };

            UFW_DEBUG("Children trajectory id: {}", childTrajectory.GetId());
            UFW_DEBUG("Children trajectory PDG code: {}", childTrajectory.GetPDGCode());
            UFW_DEBUG("Interaction number: {}", childTrajectory.GetInteractionNumber());
            UFW_DEBUG("Reaction generated by the child trajectory: {}", childTrajectory.GetReaction());
        }
    }
} // namespace sand::fake_reco

UFW_REGISTER_DYNAMIC_PROCESS_FACTORY(sand::fake_reco::fake_reco);
